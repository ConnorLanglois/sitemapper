{"version":3,"sources":["../../src/assets/sitemapper.js"],"names":["Sitemapper","options","settings","url","timeout","timeoutTable","Promise","resolve","crawl","then","sites","requestOptions","method","uri","resolveWithFullResponse","gzip","headers","requester","response","statusCode","clearTimeout","error","data","body","initializeTimeout","callback","setTimeout","cancel","parse","urlset","map","site","loc","concat","sitemapindex","sitemap","promiseArray","all","results","filter","result","reduce","prev","curr","console","warn","err","fetch","duration"],"mappings":"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","sourcesContent":["/**\r\n * Sitemap Parser\r\n *\r\n * Copyright (c) 2020 Sean Thomas Burke\r\n * Licensed under the MIT license.\r\n * @author Sean Burke <@seantomburke>\r\n */\r\n\r\nimport xmlParse from 'xml2js-es6-promise';\r\nimport request from 'request-promise';\r\n\r\n/**\r\n * @typedef {Object} Sitemapper\r\n */\r\nexport default class Sitemapper {\r\n  /**\r\n   * Construct the Sitemapper class\r\n   *\r\n   * @params {Object} options to set\r\n   * @params {string} [options.url] - the Sitemap url (e.g http://wp.seantburke.com/sitemap.xml)\r\n   * @params {Timeout} [options.timeout] - @see {timeout}\r\n   *\r\n   * @example let sitemap = new Sitemapper({\r\n   *   url: 'http://wp.seantburke.com/sitemap.xml',\r\n   *   timeout: 15000\r\n   *  });\r\n   */\r\n  constructor(options) {\r\n    const settings = options || {};\r\n    this.url = settings.url;\r\n    this.timeout = settings.timeout || 15000;\r\n    this.timeoutTable = {};\r\n  }\r\n\r\n  /**\r\n   * Gets the sites from a sitemap.xml with a given URL\r\n   *\r\n   * @public\r\n   * @param {string} [url] - the Sitemaps url (e.g http://wp.seantburke.com/sitemap.xml)\r\n   * @returns {Promise<SitesData>}\r\n   * @example sitemapper.fetch('example.xml')\r\n   *  .then((sites) => console.log(sites));\r\n   */\r\n  fetch(url = this.url) {\r\n    return new Promise(resolve => this.crawl(url).then(sites => resolve({ url, sites })));\r\n  }\r\n\r\n  /**\r\n   * Get the timeout\r\n   *\r\n   * @example console.log(sitemapper.timeout);\r\n   * @returns {Timeout}\r\n   */\r\n  static get timeout() {\r\n    return this.timeout;\r\n  }\r\n\r\n  /**\r\n   * Set the timeout\r\n   *\r\n   * @public\r\n   * @param {Timeout} duration\r\n   * @example sitemapper.timeout = 15000; // 15 seconds\r\n   */\r\n  static set timeout(duration) {\r\n    this.timeout = duration;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {string} url - url for making requests. Should be a link to a sitemaps.xml\r\n   * @example sitemapper.url = 'http://wp.seantburke.com/sitemap.xml'\r\n   */\r\n  static set url(url) {\r\n    this.url = url;\r\n  }\r\n\r\n  /**\r\n   * Get the url to parse\r\n   * @returns {string}\r\n   * @example console.log(sitemapper.url)\r\n   */\r\n  static get url() {\r\n    return this.url;\r\n  }\r\n\r\n  /**\r\n   * Requests the URL and uses xmlParse to parse through and find the data\r\n   *\r\n   * @private\r\n   * @param {string} [url] - the Sitemaps url (e.g http://wp.seantburke.com/sitemap.xml)\r\n   * @returns {Promise<ParseData>}\r\n   */\r\n  parse(url = this.url) {\r\n    const requestOptions = {\r\n      method: 'GET',\r\n      uri: url,\r\n      resolveWithFullResponse: true,\r\n      gzip: true,\r\n      headers: {\r\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36'\r\n      }\r\n    };\r\n\r\n    return new Promise((resolve) => {\r\n      const requester = request(requestOptions)\r\n        .then((response) => {\r\n          if (!response || response.statusCode !== 200) {\r\n            clearTimeout(this.timeoutTable[url]);\r\n            return resolve({ error: response.error, data: response });\r\n          }\r\n          return xmlParse(response.body);\r\n        })\r\n        .then(data => resolve({ error: null, data }))\r\n        .catch(response => resolve({ error: response.error, data: {} }));\r\n\r\n      this.initializeTimeout(url, requester, resolve);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Timeouts are necessary for large xml trees. This will cancel the call if the request is taking\r\n   * too long, but will still allow the promises to resolve.\r\n   *\r\n   * @private\r\n   * @param {string} url - url to use as a hash in the timeoutTable\r\n   * @param {Promise} requester - the promise that creates the web request to the url\r\n   * @param {Function} callback - the resolve method is used here to resolve the parent promise\r\n   */\r\n  initializeTimeout(url, requester, callback) {\r\n    // this resolves instead of rejects in order to allow other requests to continue\r\n    this.timeoutTable[url] = setTimeout(() => {\r\n      requester.cancel();\r\n\r\n      callback({\r\n        error: `request timed out after ${this.timeout} milliseconds`,\r\n        data: {},\r\n      });\r\n    }, this.timeout);\r\n  }\r\n\r\n  /**\r\n   * Recursive function that will go through a sitemaps tree and get all the sites\r\n   *\r\n   * @private\r\n   * @recursive\r\n   * @param {string} url - the Sitemaps url (e.g http://wp.seantburke.com/sitemap.xml)\r\n   * @returns {Promise<SitesArray> | Promise<ParseData>}\r\n   */\r\n  crawl(url) {\r\n    return new Promise((resolve) => {\r\n      this.parse(url).then(({ error, data }) => {\r\n        // The promise resolved, remove the timeout\r\n        clearTimeout(this.timeoutTable[url]);\r\n\r\n        if (error) {\r\n          // Fail silently\r\n          return resolve([]);\r\n        } else if (data && data.urlset && data.urlset.url) {\r\n          const sites = data.urlset.url.map(site => site.loc && site.loc[0]);\r\n\r\n          return resolve([].concat(sites));\r\n        } else if (data && data.sitemapindex) {\r\n          // Map each child url into a promise to create an array of promises\r\n          const sitemap = data.sitemapindex.sitemap.map(map => map.loc && map.loc[0]);\r\n          const promiseArray = sitemap.map(site => this.crawl(site));\r\n\r\n          // Make sure all the promises resolve then filter and reduce the array\r\n          return Promise.all(promiseArray).then(results => {\r\n            const sites = results.filter(result => !result.error)\r\n              .reduce((prev, curr) => prev.concat(curr), []);\r\n\r\n            return resolve(sites);\r\n          });\r\n        }\r\n        // Fail silently\r\n        return resolve([]);\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * /**\r\n   * Gets the sites from a sitemap.xml with a given URL\r\n   * @deprecated\r\n   * @param {string} url - url to query\r\n   * @param {getSitesCallback} callback - callback for sites and error\r\n   * @callback\r\n   */\r\n  getSites(url = this.url, callback) {\r\n    console.warn(  // eslint-disable-line no-console\r\n      'function getSites() is deprecated, please use the function fetch()'\r\n    );\r\n\r\n    let err = {};\r\n    let sites = [];\r\n    this.fetch(url).then(response => {\r\n      sites = response.sites;\r\n    }).catch(error => {\r\n      err = error;\r\n    });\r\n    return callback(err, sites);\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for the getSites method\r\n *\r\n * @callback getSitesCallback\r\n * @param {Object} error - error from callback\r\n * @param {Array} sites - an Array of sitemaps\r\n */\r\n\r\n/**\r\n * Timeout in milliseconds\r\n *\r\n * @typedef {Number} Timeout\r\n * the number of milliseconds before all requests timeout. The promises will still resolve so\r\n * you'll still receive parts of the request, but maybe not all urls\r\n * default is 15000 which is 15 seconds\r\n */\r\n\r\n/**\r\n * Resolve handler type for the promise in this.parse()\r\n *\r\n * @typedef {Object} ParseData\r\n *\r\n * @property {Error} error that either comes from `xmlParse` or `request` or custom error\r\n * @property {Object} data\r\n * @property {string} data.url - URL of sitemap\r\n * @property {Array} data.urlset - Array of returned URLs\r\n * @property {string} data.urlset.url - single Url\r\n * @property {Object} data.sitemapindex - index of sitemap\r\n * @property {string} data.sitemapindex.sitemap - Sitemap\r\n * @example {\r\n *   error: \"There was an error!\"\r\n *   data: {\r\n *     url: 'linkedin.com',\r\n *     urlset: [{\r\n *       url: 'www.linkedin.com/project1'\r\n *     },[{\r\n *       url: 'www.linkedin.com/project2'\r\n *     }]\r\n *   }\r\n * }\r\n */\r\n\r\n/**\r\n * Resolve handler type for the promise in this.parse()\r\n *\r\n * @typedef {Object} SitesData\r\n *\r\n * @property {string} url - the original url used to query the data\r\n * @property {SitesArray} sites\r\n * @example {\r\n *   url: 'linkedin.com/sitemap.xml',\r\n *   sites: [\r\n *     'linkedin.com/project1',\r\n *     'linkedin.com/project2'\r\n *   ]\r\n * }\r\n */\r\n\r\n/**\r\n * An array of urls\r\n *\r\n * @typedef {String[]} SitesArray\r\n * @example [\r\n *   'www.google.com',\r\n *   'www.linkedin.com'\r\n * ]\r\n */\r\n"],"file":"sitemapper.js"}